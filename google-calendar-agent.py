import json
import os
from datetime import datetime,UTC,timedelta
from typing import List, Dict, Any, Optional, TypedDict

import google.oauth2.credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from langchain_core.messages import AIMessage, HumanMessage
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from utils.AppConfig import AppConfig
import warnings
warnings.filterwarnings('ignore')

# Type definitions for better type hinting
class Meeting(TypedDict):
    title: str
    start_time: str
    end_time: str
    date: str

class AgentState(TypedDict):
    messages: List[Any]
    query: str
    meetings: Optional[List[Meeting]]

#load config
_ = AppConfig()
# Initialize the LLM
llm = ChatOpenAI(model="gpt-4o")

# Google Calendar API setup
SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']

def get_calendar_service():
    """Set up and return Google Calendar API service."""
    creds = None
    
    # Check if token.json exists (contains user access token)
    # This file is automatically generated during google authentication flow
    # It contains the OAuth 2.0 tokens that authorize your application to access the user's Google Calendar data
    # This file is created when:
    #   1. Your code runs the OAuth flow (flow.run_local_server())
    #   2. The user signs in to their Google account and grants permission
    #   3. Google returns access and refresh tokens
    #   4. Your code saves these tokens to token.json for future use
    if os.path.exists('token.json'):
        creds = google.oauth2.credentials.Credentials.from_authorized_user_info(
            json.loads(open('token.json').read()), SCOPES)
    
    # If credentials don't exist or are invalid, prompt user login
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'google_calendar_credentials.json', SCOPES)
            creds = flow.run_local_server(port=5678)  #port that n8n node server runs in my local
        
        # Save credentials for future use
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    
    return build('calendar', 'v3', credentials=creds)

# Define tools for the agent to use.
# The @tool decorator from LangChain is primarily useful when:
#   1. You want the LLM to decide when and how to call the tool
#   2. You want the LLM to receive the tool's description and signature for reasoning
#   3. You're using an agent framework that dynamically selects tools
# since we are calling this method directly in code, this decorator is actually not required
@tool
def get_calendar_events(time_frame: str = "today") -> List[Meeting]:
    """
    Fetch calendar events for a specified time frame (today, tomorrow, this week, etc.)
    
    Args:
        time_frame: The time period to fetch events for (today, tomorrow, this week)
        
    Returns:
        List of calendar events with title, start_time, end_time, and date
    """
    service = get_calendar_service()
    
    # Calculate time range based on time_frame
    now = datetime.now(UTC)
    
    if time_frame.lower() == "today":
        time_min = datetime(now.year, now.month, now.day).isoformat() + 'Z'
        time_max = (datetime(now.year, now.month, now.day) + timedelta(days=1)).isoformat() + 'Z'
    elif time_frame.lower() == "tomorrow":
        tomorrow = now + timedelta(days=1)
        time_min = datetime(tomorrow.year, tomorrow.month, tomorrow.day).isoformat() + 'Z'
        time_max = (datetime(tomorrow.year, tomorrow.month, tomorrow.day) + timedelta(days=1)).isoformat() + 'Z'
    elif time_frame.lower() == "this week":
        # Start of current day to end of week (next Sunday)
        time_min = datetime(now.year, now.month, now.day).isoformat() + 'Z'
        days_until_sunday = 6 - now.weekday()
        if days_until_sunday == 0:
            days_until_sunday = 7
        time_max = (datetime(now.year, now.month, now.day) + timedelta(days=days_until_sunday)).isoformat() + 'Z'
    else:
        # Default to today if time frame not recognized
        time_min = datetime(now.year, now.month, now.day).isoformat() + 'Z'
        time_max = (datetime(now.year, now.month, now.day) + timedelta(days=1)).isoformat() + 'Z'
    
    # Call the Calendar API
    events_result = service.events().list(
        calendarId='primary',
        timeMin=time_min,
        timeMax=time_max,
        singleEvents=True,
        orderBy='startTime'
    ).execute()
    
    events = events_result.get('items', [])
    
    if not events:
        return []
    
    # Format events into our Meeting type
    meetings = []
    for event in events:
        start = event['start'].get('dateTime', event['start'].get('date'))
        end = event['end'].get('dateTime', event['end'].get('date'))
        
        # Parse datetime strings
        if 'T' in start:  # This is a dateTime, not just a date
            start_dt = datetime.fromisoformat(start.replace('Z', '+00:00'))
            date_str = start_dt.strftime('%Y-%m-%d')
            start_time_str = start_dt.strftime('%H:%M')
        else:
            date_str = start
            start_time_str = "All day"
            
        if 'T' in end and start_time_str != "All day":
            end_dt = datetime.fromisoformat(end.replace('Z', '+00:00'))
            end_time_str = end_dt.strftime('%H:%M')
        else:
            end_time_str = "All day"
        
        meetings.append({
            "title": event.get('summary', 'Untitled Event'),
            "start_time": start_time_str,
            "end_time": end_time_str,
            "date": date_str
        })
    
    return meetings

# Define the process_query graph node - the code that needs to be executed
def process_query(state: AgentState) -> AgentState:
    """Process the user query and determine what to do."""
    messages = state["messages"]
    
    # Format messages for the LLM
    llm_messages = [
        HumanMessage(content=(
            "You are a virtual assistant that helps users access calendar information. "
            "Based on the user query, decide which tool to use. "
            f"User query: {state['query']}\n\n"
            "Determine the appropriate time frame (today, tomorrow, this week) from the query. "
            "Respond with the tool name and parameters."
        ))
    ]
    
    # Get response from LLM
    response = llm.invoke(llm_messages)
    
    # Add AI's planning thoughts to messages
    messages.append(AIMessage(content=f"Planning: {response.content}"))
    
    # Parse time frame from query - in a real app, you would use the LLM to extract this better
    query = state["query"].lower()
    time_frame = "today"  # Default
    
    if "tomorrow" in query:
        time_frame = "tomorrow"
    elif "this week" in query or "upcoming" in query:
        time_frame = "this week"
    
    # Call the tool to get calendar events
    meetings = get_calendar_events(time_frame)
    
    # Update the state
    return {
        "messages": messages,
        "query": state["query"],
        "meetings": meetings
    }

# Define the generate_response graph node - the code that needs to be executed
def generate_response(state: AgentState) -> AgentState:
    """Generate a response based on the calendar data."""
    messages = state["messages"]
    meetings = state["meetings"]
    
    # Format meetings as JSON string
    meetings_json = json.dumps(meetings, indent=2)
    
    # Create a summary message
    if meetings:
        content = f"I found {len(meetings)} meeting(s) in your calendar. Here's the data in JSON format:\n\n```json\n{meetings_json}\n```"
    else:
        content = f"I didn't find any meetings for the requested time period. Here's the empty result:\n\n```json\n[]\n```"
    
    # Add the response to messages
    messages.append(AIMessage(content=content))
    
    return {
        "messages": messages,
        "query": state["query"],
        "meetings": meetings
    }

# Define the graph
def build_calendar_agent():
    """Build and return the LangGraph workflow."""
    # Create a new graph
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("process_query", process_query)
    workflow.add_node("generate_response", generate_response)
    
    # Add edges
    workflow.add_edge("process_query", "generate_response")
    workflow.add_edge("generate_response", END)
    
    # Set the entry point
    workflow.set_entry_point("process_query")
    
    # Compile the graph
    return workflow.compile()

# Main function to run the agent
def run_calendar_agent(query: str) -> str:
    """Run the calendar agent with a user query."""
    # Initialize the agent
    agent = build_calendar_agent()
    
    # Initial state . This is an AgentState object
    initial_state = {
        "messages": [HumanMessage(content=query)],
        "query": query,
        "meetings": None
    }
    
    # Run the agent
    result = agent.invoke(initial_state)
    
    # Return the last message content as the response
    return result["messages"][-1].content

if __name__ == "__main__":
    # Example usage
    query = "What meetings do I have this week?"
    response = run_calendar_agent(query)
    print(response)
